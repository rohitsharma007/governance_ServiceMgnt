<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Compliance Evidence Validator - MVP Demo</title>
  <style>
    body{font-family:Inter,-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;background:#f6f7fb;margin:0}
    header{background:#fff;border-bottom:1px solid #e0e0e0;padding:14px 18px;display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    h1{font-size:16px;margin:0;font-weight:600}
    main{max-width:1100px;margin:20px auto;padding:0 16px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
    textarea{width:100%;min-height:220px;padding:12px;border-radius:8px;border:1px solid #d9d9df;background:#fff;font-size:13px}
    .card{background:#fff;border:1px solid #e5e6eb;border-radius:10px;padding:14px}
    .btn{border:none;border-radius:8px;padding:10px 14px;background:#4262ff;color:#fff;cursor:pointer;font-size:13px}
    .btn.secondary{background:#f0f1f3;color:#1a1a1a}
    .btn.warn{background:#f59e0b;color:#1a1a1a}
    table{width:100%;border-collapse:collapse;margin-top:10px}
    th,td{border-bottom:1px solid #eee;padding:8px;text-align:left;font-size:12px}
    th{background:#fafafa}
    .status-ok{color:#0a7f3f;font-weight:600}
    .status-partial{color:#b26c00;font-weight:600}
    .status-missing{color:#c02e2e;font-weight:600}
    .small{font-size:12px;color:#666}
    footer{margin-top:24px;color:#666;font-size:12px}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    input[type=text]{border:1px solid #d9d9df;border-radius:8px;padding:8px;font-size:13px}
  </style>
</head>
<body>
  <header>
    <h1>Compliance Evidence Validator - MVP Demo</h1>
    <button class="btn secondary" onclick="loadSample()">Load Sample Text</button>
            <button class="btn" onclick="runValidation()">Run Validation</button>
            <button class="btn secondary" onclick="loadMappingJson()">Load JSON Mapping</button>
            <button class="btn secondary" onclick="loadMappingCsv()">Load CSV Mapping</button>
            <button class="btn warn" onclick="exportJson()">Export JSON</button>
            <button class="btn warn" onclick="exportCsv()">Download CSV</button>

  </header>
  <main>
    <div class="row" style="margin-bottom:10px">
      <span class="small">ProjectId</span><input id="projectId" type="text" value="PRJ0023965">
      <span class="small">ChangeId</span><input id="changeId" type="text" value="CHG001057684">

    </div>
    <div class="grid">
      <div class="card">
        <h3 class="small">Paste document text (from Test Plan/Strategy/Review Form)</h3>
        <textarea id="docText" placeholder="Paste relevant sections here..."></textarea>
      </div>
      <div class="card">
        <h3 class="small">Controls → Evidence Mapping (from mapping.json)</h3>
        <div id="mappingInfo" class="small">Loading mapping...</div>
      </div>
    </div>
    <div class="card" style="margin-top:16px">
      <h3 class="small">Results</h3>
      <div id="results"></div>
    </div>
    <footer>
      MVP logic: keyword and section matching against mapping.json, producing structured JSON and CSV suitable for automation. In production, integrate Graph/Syntex/Document Intelligence, write results to a SharePoint list, and post a Teams Adaptive Card from a review flow.
    </footer>
  </main>
  <script>
    let mapping = null; let lastRows = null;
    async function loadMappingJson(){
      try {
        const resp = await fetch('mapping.json');
        mapping = await resp.json();
        const html = [`Project (map): ${mapping.projectId || ''}`, `Change (map): ${mapping.changeId || ''}`, '', ...mapping.controls.map(c=>`• ${c.id} — ${c.name} (${c.type})`)].join('<br>');
        document.getElementById('mappingInfo').innerHTML = html;
      } catch (e) {
        console.error('Failed to load mapping', e);
        document.getElementById('mappingInfo').textContent = 'Failed to load mapping.json';
      }
    }

    function parseCsv(text) {
      const rows = [];
      let row = [];
      let field = '';
      let i = 0;
      let inQuotes = false;
      while (i < text.length) {
        const char = text[i];
        if (inQuotes) {
          if (char === '"') {
            if (text[i + 1] === '"') {
              field += '"';
              i += 2;
              continue;
            } else {
              inQuotes = false;
              i++;
              continue;
            }
          } else {
            field += char;
            i++;
            continue;
          }
        } else {
          if (char === '"') {
            inQuotes = true;
            i++;
            continue;
          }
          if (char === ',') {
            row.push(field);
            field = '';
            i++;
            continue;
          }
          if (char === '\n') {
            row.push(field);
            rows.push(row);
            row = [];
            field = '';
            i++;
            continue;
          }
          if (char === '\r') {
            i++;
            continue;
          }
          field += char;
          i++;
        }
      }
      if (field.length > 0 || row.length > 0) {
        row.push(field);
        rows.push(row);
      }
      return rows;
    }

    function normalizeHeader(h) {
      return (h || '').trim().toLowerCase();
    }

    function convertCsvToMapping(rows) {
      if (!rows || rows.length === 0) return { controls: [] };
      const header = rows[0].map(normalizeHeader);
      const idx = {
        controlId: header.indexOf('control id'),
        controlName: header.indexOf('control name'),
        processType: header.indexOf('process type'),
        process: header.indexOf('process'),
        source: header.indexOf('source'),
        artefacts: header.findIndex(h => h.startsWith('control guidelines')),
        keyControl: header.indexOf('key control or non-key control'),
        frequency: header.indexOf('frequency'),
        responsible: header.indexOf('responsible party'),
        notes: header.indexOf('notes')
      };
      const controls = [];
      for (let r = 1; r < rows.length; r++) {
        const row = rows[r];
        const id = idx.controlId >= 0 ? (row[idx.controlId] || '').trim() : '';
        const name = idx.controlName >= 0 ? (row[idx.controlName] || '').trim() : '';
        if (!id && !name) continue;
        const type = idx.process >= 0 ? (row[idx.process] || '').trim() : (idx.processType >= 0 ? (row[idx.processType] || '').trim() : '');
        const artefactsRaw = idx.artefacts >= 0 ? (row[idx.artefacts] || '') : '';
        const sourceRaw = idx.source >= 0 ? (row[idx.source] || '') : '';
        const keyFlag = idx.keyControl >= 0 ? (row[idx.keyControl] || '').trim() : '';
        const frequency = idx.frequency >= 0 ? (row[idx.frequency] || '').trim() : '';
        const responsible = idx.responsible >= 0 ? (row[idx.responsible] || '').trim() : '';
        const notes = idx.notes >= 0 ? (row[idx.notes] || '').trim() : '';

        const requiredEvidence = [];
        if (artefactsRaw) {
          const lines = String(artefactsRaw).split(/\r?\n/).map(l => l.trim()).filter(Boolean);
          for (const ln of lines) {
            const cleaned = ln.replace(/^[-•]+\s*/, '').trim();
            if (!cleaned) continue;
            requiredEvidence.push({ name: cleaned, keywords: [cleaned.toLowerCase()] });
          }
        }

        const controlElements = [];
        if (sourceRaw) {
          String(sourceRaw).split(/[\/,;|]+/).map(s => s.trim()).filter(Boolean).forEach(s => controlElements.push(s));
        }

        controls.push({
          id: id || name,
          name: name || id,
          type: type || 'Testing',
          requiredEvidence,
          controlElements,
          documentSections: [],
          meta: {
            keyControl: keyFlag,
            frequency,
            responsible,
            notes
          }
        });
      }
      return { controls };
    }

    async function loadMappingCsv(){
      try {
        const csvPath = encodeURI('../governance_doc/6.17.2025 System Development, Acquisition,Maintenance - testing Controls');
        const resp = await fetch(csvPath);
        if (!resp.ok) throw new Error('HTTP '+resp.status);
        const text = await resp.text();
        const rows = parseCsv(text);
        mapping = convertCsvToMapping(rows);
        const html = [`Project (map): ${mapping.projectId || ''}`, `Change (map): ${mapping.changeId || ''}`, '', ...mapping.controls.map(c=>`• ${c.id} — ${c.name} (${c.type})`)].join('<br>');
        document.getElementById('mappingInfo').innerHTML = html;
      } catch (e) {
        console.error('Failed to load CSV mapping', e);
        document.getElementById('mappingInfo').textContent = 'Failed to load CSV mapping';
      }
    }

    async function loadMapping(){
      return loadMappingJson();
    }
    function loadSample(){
      const sample = `SDLC Governance and Quality Management review has been completed using the Governance Review Form.\n\nTest Plan: CASH August Release Test Plan V0.1.1 includes Testing Scope, Acceptance Criteria, Definition of Done for Testing and Testing Estimates. Change Impact Analysis is documented in the Impact Analysis Template.\n\nTest Strategy slides 12 to 24 describe the Testing Scope.`;
      document.getElementById('docText').value = sample;
    }
    function normalize(t){return (t||'').toLowerCase();}
    function score(foundCount,total){ if(total===0) return 1; const r=foundCount/total; return Math.round(r*100)/100; }
    function runValidation(){
      if(!mapping){alert('Mapping not loaded yet');return}
      const text = normalize(document.getElementById('docText').value);
      const rows = [];
      mapping.controls.forEach(ctrl=>{
        let evidenceFound = 0; const evidenceDetails=[];
        ctrl.requiredEvidence.forEach(ev=>{
          const found = (ev.keywords||[]).some(k=> text.includes(normalize(k)));
          evidenceFound += found?1:0; evidenceDetails.push({name: ev.name, found});
        });
        let elementsFound = 0; const elementDetails=[];
        (ctrl.controlElements||[]).forEach(el=>{ const found = text.includes(normalize(el)); elementsFound += found?1:0; elementDetails.push({name: el, found}); });
        const evRatio = score(evidenceFound, ctrl.requiredEvidence.length);
        const elRatio = score(elementsFound, (ctrl.controlElements||[]).length);
        const overall = (evRatio>=0.99 && elRatio>=0.99)? 'Fully Compliant' : ((evRatio>0 && elRatio>0)? 'Partially Compliant' : 'Missing Evidence');
        const ctrlScore = Math.round(((evRatio + elRatio)/2)*100)/100;
        rows.push({ctrl, evidenceDetails, elementDetails, overall, evRatio, elRatio, ctrlScore});
      });
      lastRows = rows; renderResults(rows);
    }
    function renderResults(rows){
      let html = '<table><thead><tr><th>Control</th><th>Evidence</th><th>Elements</th><th>Status</th><th>Score</th></tr></thead><tbody>';
      rows.forEach(r=>{
        const evText = r.evidenceDetails.map(d=>`${d.found?'✅':'❌'} ${d.name}`).join('<br>');
        const elText = r.elementDetails.map(d=>`${d.found?'✅':'❌'} ${d.name}`).join('<br>');
        const cls = r.overall==='Fully Compliant'? 'status-ok' : (r.overall==='Partially Compliant'? 'status-partial' : 'status-missing');
        html += `<tr><td><strong>${r.ctrl.id}</strong><br>${r.ctrl.name}</td><td>${evText}</td><td>${elText}</td><td class="${cls}">${r.overall}</td><td>${(r.ctrlScore*100).toFixed(0)}%</td></tr>`;
      });
      html += '</tbody></table>'; 
      document.getElementById('results').innerHTML = html;
    }
    function generateComplianceJson(){
      const meta = {
        projectId: document.getElementById('projectId').value || mapping.projectId,
        changeId: document.getElementById('changeId').value || mapping.changeId,

        runTimestamp: new Date().toISOString()
      };
      const controls = (lastRows||[]).map(r=>({
        id: r.ctrl.id,
        name: r.ctrl.name,
        type: r.ctrl.type,
        status: r.overall,
        score: r.ctrlScore,
        evidence: r.evidenceDetails.map(d=>({name:d.name,found:d.found})),
        elements: r.elementDetails.map(d=>({name:d.name,found:d.found})),
        expectedSections: r.ctrl.documentSections||[]
      }));
      const summary = {
        totalControls: controls.length,
        fully: controls.filter(c=>c.status==='Fully Compliant').length,
        partial: controls.filter(c=>c.status==='Partially Compliant').length,
        missing: controls.filter(c=>c.status==='Missing Evidence').length
      };
      return { meta, summary, controls };
    }
    function exportJson(){
      if(!lastRows){alert('Run validation first');return}
      const data = generateComplianceJson();
      const blob = new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'compliance_result.json'; a.click();
    }
    function exportCsv(){
      if(!lastRows){alert('Run validation first');return}
      const cols = ['ControlId','ControlName','Type','Status','Score','Evidence','Elements'];
      const rows = (lastRows||[]).map(r=>[
        r.ctrl.id,
        r.ctrl.name.replace(/\n/g,' '),
        r.ctrl.type||'',
        r.overall,
        (r.ctrlScore*100).toFixed(0)+'%',
        r.evidenceDetails.map(d=>`${d.found?'YES':'NO'}:${d.name}`).join('; '),
        r.elementDetails.map(d=>`${d.found?'YES':'NO'}:${d.name}`).join('; ')
      ]);
      const csv = [cols.join(','), ...rows.map(r=>r.map(v=>`"${String(v).replace(/"/g,'""')}"`).join(','))].join('\n');
      const blob = new Blob([csv],{type:'text/csv'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='compliance_result.csv'; a.click();
    }

    loadMapping();
  </script>
</body>
</html>